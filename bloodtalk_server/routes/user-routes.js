const express = require('express');
const router =express.Router();
const User = require('../db/models/user-models')
const jwt = require('jsonwebtoken');
const {secret} =require('../config');
const CryptoJS = require("crypto-js");
const UUID = require('uuid/v1');
var fs = require('fs');
var multer  = require('multer');


//var upload = multer({ dest: 'd:/uploads/' }); //setting the default 
const path = require('path');
const upload = multer({
  storage: multer.diskStorage({
    destination: function (req, file, cb) {
      cb(null, '/BloodTalk-Storage/user-image/');
    },
    filename: function (req, file, cb) {
      cb(null, new Date().valueOf() + path.extname(file.originalname));
    }
  }),
});
    //유저 insert (번호 인증시 선작업)
    router.post('/insert',(req,res)=>{
    let {userPhone,pushToken} = req.body;
    //암호화된 번호를 복호화 시켜서 insert
    userPhone = CryptoJS.AES.decrypt(userPhone,'blood').toString(CryptoJS.enc.Utf8);                                                                                                           
    //userId는 고유값이 있어야 하기 때문에 먼저 uuid를 생성해서 임의 값을 만들어준다.
    let newUser = new User({
        userPhone,
        userId : UUID(),
        pushT : pushToken
    })
    User.findOne().where('userPhone').equals(userPhone).then(user=>{
        if(user){
            return res.status(201).header('x-auth',user.authT).send('userOverlap');
        }else{
            //문자 인증 완료 시 번호 기준으로 insert
        newUser.save().then(user=>{
            if(!user){
                return res.status(400).send();
            }
            //유저 조회후 _id 기준으로 토큰 발행
            User.findOne({userPhone}).then(user=>{
                if(!user){
                    return res.status(400).send();
                }
                //secret은 config.js에 일반 난수 형태로 저장
                let token = jwt.sign({_id:user._id},secret);
                //토큰을 다시 update 해준다.
                User.updateOne({userPhone},{$set:{authT:token}}).then(user=>{
                    if(!user){
                        return res.status(400).send();
                    }
                    return res.status(201).header('x-auth',token).send(user);
                }).catch(err=>{
                    if(err){
                        res.status(400).send({error:err});
                    }
                        return res.status(400).send();
                    })
                }).catch((err)=>{
                    if(err){
                        return res.status(201).send(err);
                    }
                    return res.status(401).send();
                })
                }).catch(err=>{
                    if(err){
                        return res.status(400).send({error:err});
                    }
                    return res.status(400).send();
                })
            }
        })
    })
    

// 프로필 upate
// parameter: userImg,userName,userId,authT
router.post('/profileUpdate',(req,res)=>{
    //이미지, 이름, id, token(value) 받아오기
    const {userImg,userName,userId,token} = req.body;
    //받아온 데이터 token(authT) 기준으로 update
    User.updateOne({authT:token},{$set:{
        userImg:userImg,
        userNickname:userName,
        userId:userId}}).then(user=>{
            if(!user){
                return res.status(400).send();
            }
            return res.status(201).send(user);
        }).catch(err=>{
            if(err){
                return res.status(400).send({error:err});
            }
            return res.status(400).send();
        })
})

//id 중복체크
// parameter: userId
router.post('/idCheck',(req,res)=>{
    const {userId} = req.body;
    User.findOne({userId}).then(user=>{
        if(!user){
            //id가 존재하지 않으면 success
            return res.status(201).send('success');
        }
        //id가 존재하면 fail
        return res.status(201).send('fail');
    }).catch(err=>{
        if(err){
            return res.status(401).send(err);
        }
        return res.send();
    })

})

// userProfile check
// parameter: token
router.post('/userCheck',(req,res)=>{
    const {token} = req.body;
    User.findOne().where('authT').equals(token).then(user=>{
        if(user.userNickname === null||user.userNickname ===''){
            return res.status(201).send('N');
        }
        return res.status(201).send('Y');
    }).catch(err=>{
        if(err){
            return res.status(401).send(err);
        }
        return res.send();
    })
})

// userImageUplode
// parameter: data
router.post('/imgUpload',upload.single('fileData'), (req, res,next) => {
    if(req.file.path){
        return res.status(201).send(req.file);
    }
    //below code will read the data from the upload folder. Multer     will automatically upload the file in that folder with an  autogenerated name
    
  });

// pushTokenUpdate
// parameter: pushToken,token
router.post('/pushTokenUpdate',(req,res)=>{
    const {fcmToken,token} = req.body;
    User.findOne().where('authT').equals(token).then(user=>{
        if(!user){
            return res.status(201).send('usernull');
        }
        User.updateOne({ userId:user.userId}, {$set:{pushT:fcmToken}}).then(user=>{
            if(!user){
                return res.status(400).send();
            }
            return res.status(201).send();

        }).catch(err=>{
            if(err){
                return res.status(400).send(err);
            }
            return res.status(401).send();
        })
    }).catch(err=>{
        if(err){
            return res.status(401).send(err);
        }
        return res.status(401).send();
    })
})

// user select
// parameter: userId
router.post('/select',(req,res)=>{
    const {userId} = req.body;
    console.log(userId)
        User.findOne().where('userId').equals(userId).then(user=>{
            if(!user){
                return res.status(400).send();
            }
            console.log(user.userImg)
            return res.status(201).send(user)
        }).catch(err=>{
            if(err){
                res.status(401).send(err);
            } 
            res.status(401).send();
        })
})

// me select
// parameter: token
router.post('/iSelect',(req,res)=>{
    const {token} = req.body;
        User.findOne().where('authT').equals(token).then(user=>{
            if(!user){
                return res.status(400).send();
            }
            return res.status(201).send(user)
        }).catch(err=>{
            if(err){
                res.status(401).send(err);
            } 
            res.status(401).send();
        })
})

module.exports = router;
